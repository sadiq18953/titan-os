<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="theme-color" content="#000000" />
    <title>TITAN WARFARE</title>
    <style>
      /* --- TITAN OS DESIGN SYSTEM --- */
      :root {
        --bg-dark: #000000;
        --bg-gradient: radial-gradient(
          circle at 50% 0%,
          #1a1b26 0%,
          #000000 100%
        );
        --glass-panel: rgba(20, 20, 25, 0.8);
        --glass-border: rgba(255, 255, 255, 0.08);
        --accent: #3b82f6;
        --accent-glow: rgba(59, 130, 246, 0.4);
        --p1: #00e5ff; /* Cyan */
        --p2: #ff0055; /* Red */
        --text-main: #ffffff;
        --text-muted: #94a3b8;
        --radius: 20px;
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        user-select: none;
      }

      body {
        margin: 0;
        background: var(--bg-dark);
        background-image: var(--bg-gradient);
        color: var(--text-main);
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Ambient Background */
      .ambient {
        position: fixed;
        top: -20%;
        left: -20%;
        width: 80%;
        height: 60%;
        background: radial-gradient(
          circle,
          rgba(0, 229, 255, 0.1),
          transparent 70%
        );
        filter: blur(80px);
        z-index: -1;
        animation: float 10s infinite ease-in-out;
      }
      @keyframes float {
        0%,
        100% {
          transform: translate(0, 0);
        }
        50% {
          transform: translate(20px, 40px);
        }
      }

      /* HEADER */
      .app-header {
        padding: 15px 20px;
        padding-top: max(15px, env(safe-area-inset-top));
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        z-index: 100;
      }
      .back-btn {
        text-decoration: none;
        color: var(--text-main);
        font-weight: 600;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 16px;
        border-radius: 20px;
      }

      /* MAIN CONTENT */
      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
      }

      /* SCOREBOARD */
      .hud {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        background: var(--glass-panel);
        border: 1px solid var(--glass-border);
        padding: 15px 25px;
        border-radius: var(--radius);
      }
      .score-box {
        text-align: center;
        transition: 0.3s;
        opacity: 0.5;
      }
      .score-box.active {
        opacity: 1;
        transform: scale(1.1);
        text-shadow: 0 0 10px currentColor;
      }

      .score-label {
        font-size: 10px;
        font-weight: 700;
        letter-spacing: 1px;
        color: var(--text-muted);
      }
      .score-val {
        font-size: 28px;
        font-weight: 900;
        line-height: 1;
        margin-top: 4px;
      }

      .vs {
        font-weight: 900;
        color: #333;
        font-style: italic;
        font-size: 20px;
      }

      /* GAME BOARD */
      .game-stage {
        position: relative;
        width: 100%;
        aspect-ratio: 1/1;
        background: rgba(10, 10, 12, 0.8);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        padding: 10px;
        box-shadow: 0 20px 50px -10px rgba(0, 0, 0, 0.6);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(4, 1fr);
        gap: 8px;
        width: 100%;
        height: 100%;
      }

      .cell {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        position: relative;
        cursor: pointer;
        transition: 0.2s;
      }
      .cell:active {
        background: rgba(255, 255, 255, 0.08);
      }

      /* PIECES */
      .piece {
        position: absolute;
        top: 15%;
        left: 15%;
        width: 70%;
        height: 70%;
        border-radius: 50%;
        transform: scale(0);
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
        box-shadow: inset 0 3px 5px rgba(255, 255, 255, 0.4);
      }
      .piece.visible {
        transform: scale(1);
      }
      .piece.p1 {
        background: var(--p1);
        box-shadow: 0 0 15px var(--p1);
      }
      .piece.p2 {
        background: var(--p2);
        box-shadow: 0 0 15px var(--p2);
      }
      .piece.selected {
        border: 3px solid white;
        z-index: 10;
        box-shadow: 0 0 25px white;
      }

      /* Hint */
      .cell.valid::after {
        content: "";
        position: absolute;
        inset: 20%;
        border: 2px dashed rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        animation: spin 4s linear infinite;
      }
      @keyframes spin {
        100% {
          transform: rotate(360deg);
        }
      }

      /* CONTROLS */
      .controls {
        display: flex;
        gap: 15px;
        margin-top: 30px;
        width: 100%;
      }
      .btn {
        flex: 1;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        padding: 15px;
        border-radius: 16px;
        font-weight: 700;
        font-size: 14px;
        text-transform: uppercase;
        cursor: pointer;
      }
      .btn:active {
        background: rgba(255, 255, 255, 0.1);
        transform: scale(0.98);
      }

      /* TIMER BAR */
      .timer-track {
        width: 100%;
        height: 4px;
        background: #222;
        margin-bottom: 20px;
        border-radius: 2px;
        overflow: hidden;
      }
      .timer-bar {
        height: 100%;
        width: 100%;
        background: white;
        transform-origin: left;
        transition: transform 0.1s linear;
      }

      /* MODALS (Start / End) */
      .modal {
        position: absolute;
        inset: 0;
        background: rgba(5, 5, 5, 0.95);
        z-index: 200;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        padding: 20px;
      }
      .modal h1 {
        margin: 0 0 10px;
        font-size: 32px;
        font-weight: 900;
        letter-spacing: 2px;
      }
      .modal p {
        color: var(--text-muted);
        margin-bottom: 40px;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .modal .btn {
        width: 100%;
        max-width: 280px;
        margin: 8px 0;
        background: white;
        color: black;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      }
      .modal .btn.secondary {
        background: transparent;
        color: white;
        border: 1px solid #444;
        box-shadow: none;
      }

      /* Difficulty Select */
      #difficulty-select {
        display: none;
        flex-direction: column;
        width: 100%;
        max-width: 280px;
        gap: 10px;
      }
      .diff-btn {
        padding: 15px;
        border-radius: 12px;
        border: 1px solid #333;
        background: transparent;
        color: white;
        font-weight: 700;
      }
      .diff-btn.easy {
        border-color: #4ade80;
        color: #4ade80;
      }
      .diff-btn.med {
        border-color: #facc15;
        color: #facc15;
      }
      .diff-btn.hard {
        border-color: #ef4444;
        color: #ef4444;
      }
    </style>
  </head>
  <body>
    <div class="ambient"></div>

    <header class="app-header">
      <a href="index.html" class="back-btn">
        <svg
          width="16"
          height="16"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          viewBox="0 0 24 24"
        >
          <path d="M15 18l-6-6 6-6" />
        </svg>
        OS
      </a>
      <div style="font-weight: 700; font-size: 14px; letter-spacing: 1px">
        WARFARE
      </div>
      <div style="width: 40px"></div>
    </header>

    <main>
      <div class="hud">
        <div class="score-box" id="sb-p1" style="color: var(--p1)">
          <div class="score-label">YOU</div>
          <div class="score-val" id="score-p1">0</div>
        </div>
        <div class="vs">VS</div>
        <div class="score-box" id="sb-p2" style="color: var(--p2)">
          <div class="score-label" id="lbl-p2">CPU</div>
          <div class="score-val" id="score-p2">0</div>
        </div>
      </div>

      <div class="timer-track"><div class="timer-bar" id="timer"></div></div>

      <div class="game-stage">
        <canvas
          id="fx-canvas"
          style="
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 20;
          "
        ></canvas>
        <div class="grid" id="grid"></div>
      </div>

      <div class="controls">
        <button class="btn" onclick="game.resetRound()">Restart</button>
        <button class="btn" onclick="game.showMenu()">Menu</button>
      </div>
    </main>

    <div class="modal" id="menu-overlay">
      <h1>TITAN WARFARE</h1>
      <p>ORTHOGONAL STRATEGY</p>

      <div
        id="main-btns"
        style="
          width: 100%;
          max-width: 280px;
          display: flex;
          flex-direction: column;
        "
      >
        <button class="btn" onclick="game.selectMode('AI')">
          VS AI (SOLO)
        </button>
        <button class="btn secondary" onclick="game.start('PVP')">
          VS FRIEND
        </button>
      </div>

      <div id="difficulty-select">
        <div style="text-align: center; font-weight: bold; margin-bottom: 10px">
          SELECT DIFFICULTY
        </div>
        <button class="diff-btn easy" onclick="game.start('AI', 2)">
          EASY
        </button>
        <button class="diff-btn med" onclick="game.start('AI', 4)">
          MEDIUM
        </button>
        <button class="diff-btn hard" onclick="game.start('AI', 6)">
          HARD
        </button>
        <button
          class="btn secondary"
          onclick="game.backToMenu()"
          style="margin-top: 10px"
        >
          BACK
        </button>
      </div>
    </div>

    <script>
      const CFG = { ROWS: 4, COLS: 4, P1: 1, P2: 2, EMPTY: 0 };
      const AUDIO = new (window.AudioContext || window.webkitAudioContext)();

      class TitanGame {
        constructor() {
          this.board = new Int8Array(16).fill(CFG.EMPTY);
          this.mode = "AI";
          this.difficulty = 4;
          this.phase = "DROP";
          this.turn = CFG.P1;
          this.counts = { [CFG.P1]: 0, [CFG.P2]: 0 };
          this.scores = { [CFG.P1]: 0, [CFG.P2]: 0 };
          this.selected = -1;
          this.locked = false;
          this.timerVal = 100;

          // DOM
          this.gridEl = document.getElementById("grid");
          this.canvas = document.getElementById("fx-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.menu = document.getElementById("menu-overlay");
          this.timerEl = document.getElementById("timer");

          // UI
          this.elScoreP1 = document.getElementById("score-p1");
          this.elScoreP2 = document.getElementById("score-p2");
          this.elLblP2 = document.getElementById("lbl-p2");
          this.elBoxP1 = document.getElementById("sb-p1");
          this.elBoxP2 = document.getElementById("sb-p2");

          this.initGrid();
          this.resizeCanvas();
          window.onresize = () => this.resizeCanvas();
          setInterval(() => this.tick(), 100);
        }

        resizeCanvas() {
          this.canvas.width = this.gridEl.offsetWidth;
          this.canvas.height = this.gridEl.offsetHeight;
        }

        initGrid() {
          this.gridEl.innerHTML = "";
          for (let i = 0; i < 16; i++) {
            let c = document.createElement("div");
            c.className = "cell";
            // Mobile Touch Optimization
            c.addEventListener(
              "touchstart",
              (e) => {
                e.preventDefault();
                this.handleClick(i);
              },
              { passive: false },
            );
            c.addEventListener("click", () => this.handleClick(i));

            let p = document.createElement("div");
            p.className = "piece";
            p.id = `p-${i}`;
            c.appendChild(p);
            this.gridEl.appendChild(c);
          }
        }

        // MENU LOGIC
        selectMode(mode) {
          document.getElementById("main-btns").style.display = "none";
          document.getElementById("difficulty-select").style.display = "flex";
        }
        backToMenu() {
          document.getElementById("main-btns").style.display = "flex";
          document.getElementById("difficulty-select").style.display = "none";
        }
        showMenu() {
          this.menu.style.display = "flex";
          this.backToMenu();
        }

        // GAME LOGIC
        start(mode, difficulty = 4) {
          this.mode = mode;
          this.difficulty = difficulty;
          this.menu.style.display = "none";
          this.scores = { [CFG.P1]: 0, [CFG.P2]: 0 };
          this.updateScoreboard();

          let label = "PLAYER 2";
          if (mode === "AI") {
            if (difficulty === 2) label = "AI (EZ)";
            if (difficulty === 4) label = "AI (MED)";
            if (difficulty === 6) label = "AI (HRD)";
          }
          this.elLblP2.innerText = label;
          this.resetRound();
        }

        resetRound() {
          this.board.fill(CFG.EMPTY);
          this.phase = "DROP";
          this.turn = CFG.P1;
          this.counts = { [CFG.P1]: 0, [CFG.P2]: 0 };
          this.selected = -1;
          this.locked = false;
          this.timerVal = 100;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.render();
          this.updateTurnUI();
          this.sfx(200, "sine");
        }

        tick() {
          if (this.locked) return;
          this.timerVal -= 0.5;
          if (this.timerVal < 0) this.timerVal = 0;
          this.timerEl.style.transform = `scaleX(${this.timerVal / 100})`;
          this.timerEl.style.background =
            this.timerVal < 30 ? "#ef4444" : "#ffffff";
        }

        handleClick(idx) {
          if (this.locked) return;
          if (this.mode === "AI" && this.turn !== CFG.P1) return;

          if (this.phase === "DROP") {
            if (this.board[idx] !== CFG.EMPTY) return;
            this.execute({ type: "DROP", idx: idx, p: this.turn });
          } else {
            if (this.board[idx] === this.turn) {
              this.selected = idx;
              this.sfx(400, "triangle");
              this.render();
            } else if (this.board[idx] === CFG.EMPTY && this.selected !== -1) {
              if (this.isAdj(this.selected, idx)) {
                this.execute({
                  type: "MOVE",
                  from: this.selected,
                  to: idx,
                  p: this.turn,
                });
              } else {
                this.sfx(100, "sawtooth");
              }
            }
          }
        }

        execute(move) {
          if (move.type === "DROP") {
            this.board[move.idx] = move.p;
            this.counts[move.p]++;
            this.sfx(move.p === CFG.P1 ? 500 : 250, "sine");
          } else {
            this.board[move.to] = move.p;
            this.board[move.from] = CFG.EMPTY;
            this.selected = -1;
            this.sfx(300, "sine");
          }

          this.render();
          this.timerVal = 100;

          const winLine = this.getWinLine(move.p);
          if (winLine) {
            this.drawWinFX(winLine, move.p);
            this.scores[move.p]++;
            this.updateScoreboard();
            this.locked = true;
            this.sfx(600, "square");
            return;
          }

          if (
            this.phase === "DROP" &&
            this.counts[CFG.P1] === 4 &&
            this.counts[CFG.P2] === 4
          ) {
            this.phase = "MOVE";
            this.sfx(800, "sawtooth");
          }

          this.turn = this.turn === CFG.P1 ? CFG.P2 : CFG.P1;
          this.updateTurnUI();

          if (this.mode === "AI" && this.turn === CFG.P2) {
            this.locked = true;
            setTimeout(() => this.runAI(), 600);
          }
        }

        // AI ENGINE
        runAI() {
          const best = this.minimax(
            this.board,
            this.difficulty,
            -Infinity,
            Infinity,
            true,
          );
          if (best.move) {
            best.move.p = CFG.P2;
            this.execute(best.move);
          } else {
            this.turn = CFG.P1; // Pass
          }
          this.locked = false;
        }

        minimax(board, depth, alpha, beta, isMax) {
          if (this.checkWin(board, CFG.P2)) return { score: 10000 + depth };
          if (this.checkWin(board, CFG.P1)) return { score: -10000 - depth };
          if (depth === 0) return { score: this.eval(board) };

          let moves = this.getMoves(board, isMax ? CFG.P2 : CFG.P1);
          moves.sort((a, b) => Math.random() - 0.5); // Slight randomization

          let bestM = null;
          if (isMax) {
            let max = -Infinity;
            for (let m of moves) {
              this.doMove(board, m);
              let val = this.minimax(
                board,
                depth - 1,
                alpha,
                beta,
                false,
              ).score;
              this.undoMove(board, m);
              if (val > max) {
                max = val;
                bestM = m;
              }
              alpha = Math.max(alpha, val);
              if (beta <= alpha) break;
            }
            return { score: max, move: bestM };
          } else {
            let min = Infinity;
            for (let m of moves) {
              this.doMove(board, m);
              let val = this.minimax(board, depth - 1, alpha, beta, true).score;
              this.undoMove(board, m);
              if (val < min) {
                min = val;
                bestM = m;
              }
              beta = Math.min(beta, val);
              if (beta <= alpha) break;
            }
            return { score: min, move: bestM };
          }
        }

        eval(board) {
          let s = 0;
          const lines = [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15],
            [0, 4, 8, 12],
            [1, 5, 9, 13],
            [2, 6, 10, 14],
            [3, 7, 11, 15],
          ];
          for (let l of lines) {
            let c2 = 0,
              c1 = 0;
            for (let i of l) {
              if (board[i] === CFG.P2) c2++;
              if (board[i] === CFG.P1) c1++;
            }
            if (c2 > 0 && c1 === 0) s += Math.pow(10, c2);
            if (c1 > 0 && c2 === 0) s -= Math.pow(10, c1) * 1.2;
          }
          return s;
        }

        // HELPERS
        doMove(b, m) {
          if (m.type === "DROP") b[m.idx] = m.p;
          else {
            b[m.to] = m.p;
            b[m.from] = CFG.EMPTY;
          }
        }
        undoMove(b, m) {
          if (m.type === "DROP") b[m.idx] = CFG.EMPTY;
          else {
            b[m.from] = m.p;
            b[m.to] = CFG.EMPTY;
          }
        }
        getMoves(b, p) {
          let m = [];
          if (this.phase === "DROP") {
            for (let i = 0; i < 16; i++)
              if (b[i] === CFG.EMPTY) m.push({ type: "DROP", idx: i, p: p });
          } else {
            for (let i = 0; i < 16; i++) {
              if (b[i] === p) {
                let n = this.getNeighbors(i);
                for (let d of n)
                  if (b[d] === CFG.EMPTY)
                    m.push({ type: "MOVE", from: i, to: d, p: p });
              }
            }
          }
          return m;
        }
        getNeighbors(i) {
          let n = [];
          let r = i >> 2,
            c = i & 3;
          if (r > 0) n.push(i - 4);
          if (r < 3) n.push(i + 4);
          if (c > 0) n.push(i - 1);
          if (c < 3) n.push(i + 1);
          return n;
        }
        isAdj(a, b) {
          let r1 = a >> 2,
            c1 = a & 3,
            r2 = b >> 2,
            c2 = b & 3;
          return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
        }
        checkWin(b, p) {
          const lines = [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15],
            [0, 4, 8, 12],
            [1, 5, 9, 13],
            [2, 6, 10, 14],
            [3, 7, 11, 15],
          ];
          return lines.some((l) => l.every((i) => b[i] === p));
        }
        getWinLine(p) {
          const lines = [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15],
            [0, 4, 8, 12],
            [1, 5, 9, 13],
            [2, 6, 10, 14],
            [3, 7, 11, 15],
          ];
          return lines.find((l) => l.every((i) => this.board[i] === p));
        }

        // RENDER & UI
        render() {
          for (let i = 0; i < 16; i++) {
            const el = document.getElementById(`p-${i}`);
            const cell = el.parentElement;
            el.className = "piece";
            cell.classList.remove("valid");

            if (this.board[i] === CFG.P1) el.classList.add("visible", "p1");
            if (this.board[i] === CFG.P2) el.classList.add("visible", "p2");
            if (i === this.selected) el.classList.add("selected");

            if (this.phase === "MOVE" && !this.locked && this.selected !== -1) {
              if (this.board[i] === CFG.EMPTY && this.isAdj(this.selected, i)) {
                cell.classList.add("valid");
              }
            }
          }
        }

        drawWinFX(line, winner) {
          const color = winner === CFG.P1 ? "#00e5ff" : "#ff0055";
          const cells = document.querySelectorAll(".cell");
          const start = cells[line[0]].getBoundingClientRect();
          const end = cells[line[3]].getBoundingClientRect();
          const wrap = this.gridEl.getBoundingClientRect();

          this.ctx.beginPath();
          this.ctx.strokeStyle = color;
          this.ctx.lineWidth = 8;
          this.ctx.lineCap = "round";
          this.ctx.shadowColor = color;
          this.ctx.shadowBlur = 20;
          this.ctx.moveTo(
            start.left - wrap.left + start.width / 2,
            start.top - wrap.top + start.height / 2,
          );
          this.ctx.lineTo(
            end.left - wrap.left + end.width / 2,
            end.top - wrap.top + end.height / 2,
          );
          this.ctx.stroke();
        }

        updateScoreboard() {
          this.elScoreP1.innerText = this.scores[CFG.P1];
          this.elScoreP2.innerText = this.scores[CFG.P2];
        }

        updateTurnUI() {
          if (this.turn === CFG.P1) {
            this.elBoxP1.classList.add("active");
            this.elBoxP2.classList.remove("active");
          } else {
            this.elBoxP1.classList.remove("active");
            this.elBoxP2.classList.add("active");
          }
        }

        sfx(f, t) {
          if (AUDIO.state === "suspended") AUDIO.resume();
          let o = AUDIO.createOscillator();
          let g = AUDIO.createGain();
          o.connect(g);
          g.connect(AUDIO.destination);
          o.type = t;
          o.frequency.setValueAtTime(f, AUDIO.currentTime);
          g.gain.setValueAtTime(0.1, AUDIO.currentTime);
          g.gain.linearRampToValueAtTime(0, AUDIO.currentTime + 0.1);
          o.start();
          o.stop(AUDIO.currentTime + 0.1);
        }
      }

      const game = new TitanGame();
    </script>
  </body>
</html>
