<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QUANTUM GRID | Ultimate Tic-Tac-Toe</title>
    <style>
      /* === VIBRANT COLOR THEME === */
      :root {
        --bg-primary: #0f172a;
        --bg-secondary: #1e293b;
        --accent-blue: #3b82f6;
        --accent-purple: #8b5cf6;
        --accent-pink: #ec4899;
        --accent-cyan: #06b6d4;
        --accent-green: #10b981;
        --accent-yellow: #f59e0b;
        --text-light: #f1f5f9;
        --text-dim: #94a3b8;
        --glass-white: rgba(255, 255, 255, 0.1);
        --glass-dark: rgba(30, 41, 59, 0.8);
        --glow-blue: 0 0 20px rgba(59, 130, 246, 0.4);
        --glow-purple: 0 0 20px rgba(139, 92, 246, 0.4);
        --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        background: linear-gradient(135deg, #0f172a, #1e293b);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-family:
          "Inter",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        overflow-x: hidden; /* Prevent horizontal scroll */
        color: var(--text-light);
        padding: 10px;
      }

      /* === BACK BUTTON === */
      .back-btn {
        position: fixed;
        top: 20px;
        left: 20px;
        padding: 12px 20px;
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid var(--accent-blue);
        border-radius: 12px;
        color: var(--accent-blue);
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 1000;
        backdrop-filter: blur(10px);
      }

      .back-btn:hover {
        background: var(--accent-blue);
        color: white;
        transform: translateX(-5px);
      }

      /* === START SCREEN === */
      .start-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.98);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        backdrop-filter: blur(10px);
        padding: 20px;
        overflow-y: auto; /* Allow scrolling on small screens if content is tall */
      }

      .start-title {
        font-size: clamp(2rem, 5vw, 3.5rem); /* Responsive font size */
        font-weight: 800;
        background: linear-gradient(
          90deg,
          var(--accent-blue),
          var(--accent-purple)
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        margin-bottom: 10px;
        text-align: center;
        line-height: 1.2;
      }

      .start-subtitle {
        font-size: 1.2rem;
        color: var(--text-dim);
        margin-bottom: 50px;
        text-align: center;
      }

      .mode-selector {
        display: flex;
        gap: 20px;
        margin-bottom: 40px;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
      }

      .mode-card {
        width: 100%;
        max-width: 250px; /* Limits width on desktop */
        padding: 25px;
        background: var(--glass-dark);
        border-radius: 20px;
        border: 2px solid transparent;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
        backdrop-filter: blur(10px);
      }

      .mode-card:hover {
        transform: translateY(-10px);
        border-color: var(--accent-blue);
        box-shadow: var(--glow-blue);
      }

      .mode-card.active {
        border-color: var(--accent-blue);
        background: rgba(59, 130, 246, 0.1);
        box-shadow: var(--glow-blue);
      }

      .mode-icon {
        font-size: 2.5rem;
        margin-bottom: 15px;
      }

      .mode-title {
        font-size: 1.3rem;
        font-weight: 700;
        margin-bottom: 10px;
        color: white;
      }

      .mode-desc {
        font-size: 0.85rem;
        color: var(--text-dim);
        line-height: 1.4;
      }

      .difficulty-selector {
        margin-bottom: 40px;
        text-align: center;
        opacity: 0;
        height: 0;
        overflow: hidden;
        transition: all 0.3s ease;
        width: 100%;
      }

      .difficulty-selector.show {
        opacity: 1;
        height: auto;
      }

      .difficulty-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .diff-btn {
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        color: var(--text-dim);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        flex: 1 1 auto; /* Allow buttons to grow/shrink */
        min-width: 80px;
      }

      .diff-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
      }

      .diff-btn.active {
        background: linear-gradient(
          135deg,
          var(--accent-blue),
          var(--accent-purple)
        );
        color: white;
        border-color: transparent;
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
      }

      .start-btn {
        padding: 16px 40px;
        background: linear-gradient(
          135deg,
          var(--accent-blue),
          var(--accent-purple)
        );
        border: none;
        border-radius: 16px;
        color: white;
        font-size: 1.1rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        text-transform: uppercase;
        letter-spacing: 1px;
        width: 100%;
        max-width: 300px;
      }

      /* === HEADER === */
      .header {
        text-align: center;
        margin-bottom: 20px;
        padding: 10px;
        display: none;
        width: 100%;
      }

      .title {
        font-size: clamp(1.8rem, 4vw, 2.8rem);
        font-weight: 800;
        background: linear-gradient(
          90deg,
          var(--accent-blue),
          var(--accent-purple)
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        margin-bottom: 5px;
      }

      .subtitle {
        font-size: clamp(0.8rem, 2vw, 1rem);
        color: var(--text-dim);
        font-weight: 500;
        letter-spacing: 2px;
        text-transform: uppercase;
      }

      /* === GAME BOARD CONTAINER === */
      .game-container {
        position: relative;
        padding: 20px;
        background: var(--glass-dark);
        backdrop-filter: blur(20px);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: var(--shadow-lg);
        display: none;
        width: 100%;
        max-width: 500px; /* Restrict max width on tablet/desktop */
        margin: 0 auto;
      }

      /* === MAIN GAME BOARD === */
      .game-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px; /* Space between big zones */
        position: relative;
        width: 100%;
        aspect-ratio: 1; /* Keep the entire board square */
      }

      /* === ZONES (SMALL BOARDS) === */
      .zone {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 4px; /* Space between small cells */
        padding: 8px;
        background: rgba(30, 41, 59, 0.6);
        border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.05);
        transition: all 0.3s ease;
        position: relative;
        width: 100%;
        height: 100%; /* Ensure it fills the grid cell */
      }

      .zone.active {
        background: rgba(59, 130, 246, 0.15);
        border-color: var(--accent-blue);
        box-shadow: var(--glow-blue);
        transform: scale(1.02);
        z-index: 10;
      }

      .zone.inactive {
        opacity: 0.5;
        pointer-events: none;
      }

      .zone.won {
        background: rgba(59, 130, 246, 0.2);
      }

      .zone.won::after {
        content: attr(data-winner);
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3rem; /* fluid size logic handled by flex centering */
        font-weight: 900;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 10px;
        z-index: 2;
      }

      .zone.won[data-winner="X"]::after {
        color: var(--accent-blue);
        text-shadow: 0 0 20px var(--accent-blue);
      }
      .zone.won[data-winner="O"]::after {
        color: var(--accent-pink);
        text-shadow: 0 0 20px var(--accent-pink);
      }

      /* === CELLS === */
      .cell {
        /* REMOVED FIXED WIDTH/HEIGHT */
        width: 100%;
        height: 100%;
        aspect-ratio: 1; /* Key fix: forces square shape based on width */

        background: rgba(255, 255, 255, 0.08);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;

        /* Responsive font size based on viewport width */
        font-size: clamp(0.8rem, 4vw, 1.8rem);
        font-weight: 700;
        cursor: pointer;
        border: 1px solid transparent;
      }

      .cell:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .cell.x {
        color: var(--accent-blue);
        text-shadow: 0 0 5px rgba(59, 130, 246, 0.5);
      }
      .cell.o {
        color: var(--accent-pink);
        text-shadow: 0 0 5px rgba(236, 72, 153, 0.5);
      }

      /* === GAME INFO & CONTROLS === */
      .mode-indicator {
        position: absolute;
        top: -40px;
        right: 0;
        padding: 6px 12px;
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid var(--accent-blue);
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--accent-blue);
        text-transform: uppercase;
      }

      .game-info {
        margin-top: 20px;
        padding: 15px;
        background: var(--glass-dark);
        border-radius: 16px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        text-align: center;
      }

      .player-info {
        padding: 10px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid transparent;
        transition: all 0.3s ease;
      }

      .player-info.active {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.2),
          transparent
        );
        border-color: var(--accent-blue);
      }

      .player-info.p2.active {
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          transparent
        );
        border-color: var(--accent-pink);
      }

      .player-symbol {
        font-size: 1.5rem;
        font-weight: 800;
      }
      .player-x .player-symbol {
        color: var(--accent-blue);
      }
      .player-o .player-symbol {
        color: var(--accent-pink);
      }

      .status-bar {
        margin-top: 15px;
        text-align: center;
        font-size: 0.95rem;
        display: flex;
        justify-content: center;
      }

      .status-text {
        padding: 10px 20px;
        background: rgba(59, 130, 246, 0.1);
        border-radius: 30px;
        border: 1px solid var(--accent-blue);
        color: var(--accent-blue);
        width: 100%;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr; /* 2 columns for buttons */
        gap: 10px;
        margin-top: 20px;
      }

      .controls .btn {
        width: 100%;
        justify-content: center;
        padding: 12px;
        font-size: 0.85rem;
      }

      /* Make "New Game" button span full width */
      .controls .btn-primary {
        grid-column: span 2;
      }

      .btn {
        border: none;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        text-transform: uppercase;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--accent-blue),
          var(--accent-purple)
        );
        color: white;
      }
      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      /* === WIN SCREEN === */
      .win-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
        backdrop-filter: blur(10px);
        padding: 20px;
      }

      .win-content {
        background: var(--glass-dark);
        padding: 30px;
        border-radius: 24px;
        text-align: center;
        width: 100%;
        max-width: 400px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .winner-symbol {
        font-size: 4rem;
        font-weight: 900;
        margin: 15px 0;
      }
      .winner-x {
        color: var(--accent-blue);
        text-shadow: 0 0 30px var(--accent-blue);
      }
      .winner-o {
        color: var(--accent-pink);
        text-shadow: 0 0 30px var(--accent-pink);
      }

      .stats {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
        margin: 20px 0;
      }
      .stat {
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }
      .stat-value {
        font-size: 1.2rem;
        font-weight: 700;
        color: white;
      }
      .stat-label {
        font-size: 0.7rem;
        color: var(--text-dim);
      }

      .particles-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
      }

      /* === MOBILE SPECIFIC OVERRIDES === */
      @media (max-width: 480px) {
        /* Fix Back Button overlap */
        .back-btn {
          position: relative;
          top: auto;
          left: auto;
          margin-bottom: 10px;
          display: inline-flex;
          background: transparent;
          border: none;
          padding: 0;
          color: var(--text-dim);
        }

        .game-container {
          padding: 12px;
          margin-top: 0;
        }

        .game-board {
          gap: 6px; /* Tighter gaps on mobile */
        }

        .zone {
          padding: 3px;
          gap: 2px;
          border-width: 1px;
        }

        /* Ensure the big "X" or "O" overlay fits the smaller zones */
        .zone.won::after {
          font-size: 2rem;
          border-radius: 8px;
        }

        .controls {
          gap: 8px;
        }

        .game-info {
          gap: 10px;
        }

        .mode-indicator {
          position: relative;
          top: auto;
          right: auto;
          display: inline-block;
          margin-bottom: 10px;
          width: 100%;
          text-align: center;
        }
      }
    </style>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- Back Button -->
    <a href="index.html" class="back-btn"> ‚Üê Back to OS </a>

    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
      <h1 class="start-title">QUANTUM GRID</h1>
      <div class="start-subtitle">Select your game mode</div>

      <div class="mode-selector">
        <div
          class="mode-card"
          data-mode="single"
          onclick="selectMode('single')"
        >
          <div class="mode-icon">ü§ñ</div>
          <div class="mode-title">VS AI</div>
          <div class="mode-desc">
            Challenge the computer AI with adjustable difficulty levels
          </div>
        </div>

        <div class="mode-card" data-mode="multi" onclick="selectMode('multi')">
          <div class="mode-icon">üë•</div>
          <div class="mode-title">MULTIPLAYER</div>
          <div class="mode-desc">
            Play with a friend on the same device - perfect for two players
          </div>
        </div>
      </div>

      <div class="difficulty-selector" id="difficultySelector">
        <div class="difficulty-title">Select AI Difficulty</div>
        <div class="difficulty-buttons">
          <button
            class="diff-btn"
            data-diff="easy"
            onclick="selectDifficulty('easy')"
          >
            Easy
          </button>
          <button
            class="diff-btn"
            data-diff="medium"
            onclick="selectDifficulty('medium')"
          >
            Medium
          </button>
          <button
            class="diff-btn active"
            data-diff="hard"
            onclick="selectDifficulty('hard')"
          >
            Hard
          </button>
          <button
            class="diff-btn"
            data-diff="impossible"
            onclick="selectDifficulty('impossible')"
          >
            Impossible
          </button>
        </div>
      </div>

      <button class="start-btn" onclick="startGame()" id="startBtn">
        Start Game
      </button>
    </div>

    <!-- Floating Particles Background -->
    <canvas class="particles-bg" id="particles"></canvas>

    <!-- Header -->
    <div class="header" id="header">
      <h1 class="title">QUANTUM GRID</h1>
      <div class="subtitle">Ultimate Tic-Tac-Toe</div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="gameContainer">
      <!-- Mode Indicator -->
      <div class="mode-indicator" id="modeIndicator">VS AI ‚Ä¢ Hard</div>

      <!-- Main Game Board -->
      <div class="game-board" id="gameBoard">
        <!-- Zones will be generated here -->
      </div>

      <!-- Game Info -->
      <div class="game-info">
        <div class="player-info player-x active" id="playerX">
          <div class="player-name" id="playerXName">PLAYER 1</div>
          <div class="player-symbol">X</div>
          <div class="player-score" id="scoreX">0</div>
        </div>
        <div class="player-info player-o" id="playerO">
          <div class="player-name" id="playerOName">AI</div>
          <div class="player-symbol">O</div>
          <div class="player-score" id="scoreO">0</div>
        </div>
      </div>

      <!-- Status Bar -->
      <div class="status-bar">
        <div class="status-text" id="status">Your turn! Click any cell</div>
      </div>

      <!-- Controls -->
      <div class="controls">
        <button class="btn btn-primary" onclick="newGame()">
          <span>üîÑ New Game</span>
        </button>
        <button class="btn btn-secondary" onclick="toggleAI()" id="aiBtn">
          <span>ü§ñ AI: Hard</span>
        </button>
        <button class="btn btn-secondary" onclick="toggleSound()" id="soundBtn">
          <span>üîä Sound On</span>
        </button>
        <button class="btn btn-secondary" onclick="showHelp()">
          <span>‚ùì Help</span>
        </button>
        <button class="btn btn-secondary" onclick="backToMenu()">
          <span>‚Üê Main Menu</span>
        </button>
      </div>
    </div>

    <!-- Win Screen -->
    <div class="win-screen" id="winScreen">
      <div class="win-content">
        <div class="win-title" id="winTitle">VICTORY!</div>
        <div class="winner-symbol" id="winnerSymbol"></div>
        <div class="stats">
          <div class="stat">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="gameTime">0:00</div>
          </div>
          <div class="stat">
            <div class="stat-label">Moves</div>
            <div class="stat-value" id="totalMoves">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Mode</div>
            <div class="stat-value" id="gameMode">VS AI</div>
          </div>
        </div>
        <button
          class="btn btn-primary"
          onclick="playAgain()"
          style="width: 100%; margin-bottom: 15px"
        >
          Play Again
        </button>
        <button
          class="btn btn-secondary"
          onclick="backToMenu()"
          style="width: 100%"
        >
          Main Menu
        </button>
      </div>
    </div>

    <script>
      // ===== GAME STATE =====
      const gameState = {
        board: Array(9)
          .fill()
          .map(() => Array(9).fill(null)),
        macro: Array(9).fill(null),
        currentZone: -1,
        currentPlayer: "X",
        gameActive: false,
        gameMode: "single", // 'single' or 'multi'
        aiDifficulty: "hard",
        scores: { X: 0, O: 0 },
        moveCount: 0,
        startTime: null,
        timerInterval: null,
        soundEnabled: true,
        aiThinking: false,
      };

      // ===== START SCREEN FUNCTIONS =====
      function selectMode(mode) {
        gameState.gameMode = mode;

        // Update UI
        document.querySelectorAll(".mode-card").forEach((card) => {
          card.classList.toggle("active", card.dataset.mode === mode);
        });

        // Show/hide difficulty selector for single player
        const diffSelector = document.getElementById("difficultySelector");
        if (mode === "single") {
          diffSelector.classList.add("show");
        } else {
          diffSelector.classList.remove("show");
        }

        // Update button text
        document.getElementById("startBtn").textContent =
          mode === "single" ? "Start Game vs AI" : "Start Multiplayer Game";
      }

      function selectDifficulty(difficulty) {
        gameState.aiDifficulty = difficulty;

        // Update UI
        document.querySelectorAll(".diff-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.diff === difficulty);
        });

        // Update AI button in game
        document.getElementById("aiBtn").innerHTML =
          `<span>ü§ñ AI: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</span>`;
      }

      function startGame() {
        // Hide start screen
        document.getElementById("startScreen").style.display = "none";

        // Show game elements
        document.getElementById("header").style.display = "block";
        document.getElementById("gameContainer").style.display = "block";

        // Update UI based on mode
        const modeIndicator = document.getElementById("modeIndicator");
        const playerOName = document.getElementById("playerOName");

        if (gameState.gameMode === "single") {
          modeIndicator.textContent = `VS AI ‚Ä¢ ${gameState.aiDifficulty.charAt(0).toUpperCase() + gameState.aiDifficulty.slice(1)}`;
          playerOName.textContent = "AI";
        } else {
          modeIndicator.textContent = "MULTIPLAYER";
          playerOName.textContent = "PLAYER 2";
        }

        // Initialize game
        initGame();
      }

      function backToMenu() {
        // Hide game elements
        document.getElementById("header").style.display = "none";
        document.getElementById("gameContainer").style.display = "none";
        document.getElementById("winScreen").style.display = "none";

        // Show start screen
        document.getElementById("startScreen").style.display = "flex";

        // Clear any timers
        if (gameState.timerInterval) {
          clearInterval(gameState.timerInterval);
          gameState.timerInterval = null;
        }
      }

      // ===== GAME INITIALIZATION =====
      function initGame() {
        gameState.board = Array(9)
          .fill()
          .map(() => Array(9).fill(null));
        gameState.macro = Array(9).fill(null);
        gameState.currentZone = -1;
        gameState.currentPlayer = "X";
        gameState.gameActive = true;
        gameState.moveCount = 0;
        gameState.startTime = Date.now();
        gameState.aiThinking = false;

        // Clear timer
        if (gameState.timerInterval) {
          clearInterval(gameState.timerInterval);
        }

        // Start timer
        gameState.timerInterval = setInterval(updateTimer, 1000);

        // Update UI
        updateBoard();
        updateStatus();
        updatePlayerIndicators();
        hideWinScreen();

        // Update AI button text
        document.getElementById("aiBtn").innerHTML =
          `<span>ü§ñ AI: ${gameState.aiDifficulty.charAt(0).toUpperCase() + gameState.aiDifficulty.slice(1)}</span>`;

        // Start particles animation
        initParticles();
      }

      // ===== BOARD FUNCTIONS =====
      function updateBoard() {
        const gameBoard = document.getElementById("gameBoard");
        gameBoard.innerHTML = "";

        // Create 9 zones (small boards)
        for (let zone = 0; zone < 9; zone++) {
          const zoneDiv = document.createElement("div");
          zoneDiv.className = "zone";
          zoneDiv.id = `zone-${zone}`;

          // Set zone status
          if (gameState.macro[zone]) {
            zoneDiv.classList.add("won");
            zoneDiv.setAttribute("data-winner", gameState.macro[zone]);
          } else if (
            gameState.currentZone === -1 ||
            gameState.currentZone === zone
          ) {
            zoneDiv.classList.add("active");
          } else {
            zoneDiv.classList.add("inactive");
          }

          // Create 9 cells in each zone
          for (let cell = 0; cell < 9; cell++) {
            const cellDiv = document.createElement("div");
            cellDiv.className = "cell";
            cellDiv.id = `cell-${zone}-${cell}`;

            // Set cell content
            if (gameState.board[zone][cell]) {
              cellDiv.textContent = gameState.board[zone][cell];
              cellDiv.classList.add(gameState.board[zone][cell].toLowerCase());
            } else {
              // Add click event only if cell is empty
              cellDiv.onclick = () => makeMove(zone, cell);
            }

            zoneDiv.appendChild(cellDiv);
          }

          gameBoard.appendChild(zoneDiv);
        }
      }

      function makeMove(zone, cell) {
        // Validate move
        if (!gameState.gameActive || gameState.aiThinking) return;
        if (gameState.currentPlayer !== "X") return;
        if (!isValidMove(zone, cell)) return;

        // Play sound
        playSound("move");

        // Execute move
        gameState.board[zone][cell] = "X";
        gameState.moveCount++;

        // Check if zone is won
        if (checkZoneWin(zone, "X")) {
          gameState.macro[zone] = "X";
          playSound("win");
        } else if (isZoneFull(zone)) {
          gameState.macro[zone] = "T"; // Tie
        }

        // Check for game win
        if (checkGameWin("X")) {
          gameWin("X");
          return;
        }

        // Determine next zone
        gameState.currentZone = gameState.macro[cell] ? -1 : cell;
        gameState.currentPlayer = "O";

        // Update UI
        updateBoard();
        updateStatus();
        updatePlayerIndicators();

        // Handle next move based on game mode
        if (gameState.gameActive) {
          if (gameState.gameMode === "single") {
            // AI move after delay
            gameState.aiThinking = true;
            updateStatus();
            setTimeout(makeAIMove, 800);
          }
          // In multiplayer mode, just wait for Player 2's click
        }
      }

      function makeAIMove() {
        if (!gameState.gameActive || gameState.currentPlayer !== "O") return;

        const move = getAIMove();
        if (move) {
          playSound("move");

          gameState.board[move.zone][move.cell] = "O";
          gameState.moveCount++;

          // Check if zone is won
          if (checkZoneWin(move.zone, "O")) {
            gameState.macro[move.zone] = "O";
            playSound("win");
          } else if (isZoneFull(move.zone)) {
            gameState.macro[move.zone] = "T";
          }

          // Check for game win
          if (checkGameWin("O")) {
            gameWin("O");
            return;
          }

          // Determine next zone
          gameState.currentZone = gameState.macro[move.cell] ? -1 : move.cell;
          gameState.currentPlayer = "X";
        }

        gameState.aiThinking = false;
        updateBoard();
        updateStatus();
        updatePlayerIndicators();
      }

      // ===== AI FUNCTIONS =====
      function getAIMove() {
        const moves = getValidMoves();
        if (moves.length === 0) return null;

        // Different AI strategies based on difficulty
        switch (gameState.aiDifficulty) {
          case "easy":
            // Random moves with occasional mistakes
            if (Math.random() < 0.3) {
              // Make a random "bad" move (avoid winning moves)
              const nonWinningMoves = moves.filter((move) => {
                const tempZone = [...gameState.board[move.zone]];
                tempZone[move.cell] = "O";
                return !checkWinInArray(tempZone, "O");
              });
              if (nonWinningMoves.length > 0) {
                return nonWinningMoves[
                  Math.floor(Math.random() * nonWinningMoves.length)
                ];
              }
            }
            return moves[Math.floor(Math.random() * moves.length)];

          case "medium":
            // Try to win zone, otherwise random
            for (let move of moves) {
              const tempZone = [...gameState.board[move.zone]];
              tempZone[move.cell] = "O";
              if (checkWinInArray(tempZone, "O")) {
                return move;
              }
            }

            // Block player sometimes
            if (Math.random() < 0.7) {
              for (let move of moves) {
                const tempZone = [...gameState.board[move.zone]];
                tempZone[move.cell] = "X";
                if (checkWinInArray(tempZone, "X")) {
                  return move;
                }
              }
            }
            return moves[Math.floor(Math.random() * moves.length)];

          case "hard":
            // Smart AI with strategy
            return getSmartAIMove(moves);

          case "impossible":
            // Try to find optimal move
            return getOptimalAIMove(moves);
        }

        return moves[0];
      }

      function getSmartAIMove(moves) {
        // 1. Try to win a zone
        for (let move of moves) {
          const tempZone = [...gameState.board[move.zone]];
          tempZone[move.cell] = "O";
          if (checkWinInArray(tempZone, "O")) {
            return move;
          }
        }

        // 2. Block player from winning a zone
        for (let move of moves) {
          const tempZone = [...gameState.board[move.zone]];
          tempZone[move.cell] = "X";
          if (checkWinInArray(tempZone, "X")) {
            return move;
          }
        }

        // 3. Take center of zone if available
        const centerMoves = moves.filter((m) => m.cell === 4);
        if (centerMoves.length > 0) {
          return centerMoves[0];
        }

        // 4. Take center of board if available
        if (gameState.currentZone === -1) {
          const centerZone = moves.filter((m) => m.zone === 4);
          if (centerZone.length > 0) {
            return centerZone[0];
          }
        }

        // 5. Take corners
        const corners = [0, 2, 6, 8];
        for (let corner of corners) {
          const cornerMoves = moves.filter((m) => m.cell === corner);
          if (cornerMoves.length > 0) {
            return cornerMoves[0];
          }
        }

        // 6. Random move
        return moves[Math.floor(Math.random() * moves.length)];
      }

      function getOptimalAIMove(moves) {
        // For "Impossible" difficulty, use minimax algorithm
        let bestScore = -Infinity;
        let bestMove = moves[0];

        for (let move of moves) {
          // Make move
          gameState.board[move.zone][move.cell] = "O";
          const zoneWon = checkZoneWin(move.zone, "O");
          const prevMacro = gameState.macro[move.zone];
          if (zoneWon) gameState.macro[move.zone] = "O";

          const newActiveZone = gameState.macro[move.cell] ? -1 : move.cell;
          const prevActiveZone = gameState.currentZone;
          gameState.currentZone = newActiveZone;

          // Evaluate
          const score = minimax(3, false, -Infinity, Infinity);

          // Undo move
          gameState.board[move.zone][move.cell] = null;
          gameState.macro[move.zone] = prevMacro;
          gameState.currentZone = prevActiveZone;

          if (score > bestScore) {
            bestScore = score;
            bestMove = move;
          }
        }

        return bestMove;
      }

      function minimax(depth, isMaximizing, alpha, beta) {
        // Check terminal states
        if (checkGameWin("O")) return 100;
        if (checkGameWin("X")) return -100;
        if (depth === 0 || getValidMoves().length === 0) return 0;

        if (isMaximizing) {
          let maxEval = -Infinity;
          const moves = getValidMoves();

          for (let move of moves) {
            // Make move
            gameState.board[move.zone][move.cell] = "O";
            const zoneWon = checkZoneWin(move.zone, "O");
            const prevMacro = gameState.macro[move.zone];
            if (zoneWon) gameState.macro[move.zone] = "O";

            const newActiveZone = gameState.macro[move.cell] ? -1 : move.cell;
            const prevActiveZone = gameState.currentZone;
            gameState.currentZone = newActiveZone;

            // Evaluate
            const eval = minimax(depth - 1, false, alpha, beta);

            // Undo move
            gameState.board[move.zone][move.cell] = null;
            gameState.macro[move.zone] = prevMacro;
            gameState.currentZone = prevActiveZone;

            maxEval = Math.max(maxEval, eval);
            alpha = Math.max(alpha, eval);
            if (beta <= alpha) break;
          }
          return maxEval;
        } else {
          let minEval = Infinity;
          const moves = getValidMoves();

          for (let move of moves) {
            // Make move
            gameState.board[move.zone][move.cell] = "X";
            const zoneWon = checkZoneWin(move.zone, "X");
            const prevMacro = gameState.macro[move.zone];
            if (zoneWon) gameState.macro[move.zone] = "X";

            const newActiveZone = gameState.macro[move.cell] ? -1 : move.cell;
            const prevActiveZone = gameState.currentZone;
            gameState.currentZone = newActiveZone;

            // Evaluate
            const eval = minimax(depth - 1, true, alpha, beta);

            // Undo move
            gameState.board[move.zone][move.cell] = null;
            gameState.macro[move.zone] = prevMacro;
            gameState.currentZone = prevActiveZone;

            minEval = Math.min(minEval, eval);
            beta = Math.min(beta, eval);
            if (beta <= alpha) break;
          }
          return minEval;
        }
      }

      // ===== GAME LOGIC =====
      function isValidMove(zone, cell) {
        // Check if zone is won
        if (gameState.macro[zone]) return false;

        // Check if cell is empty
        if (gameState.board[zone][cell]) return false;

        // Check if move is in correct zone
        if (gameState.currentZone !== -1 && gameState.currentZone !== zone)
          return false;

        return true;
      }

      function getValidMoves() {
        const moves = [];
        const zones =
          gameState.currentZone === -1
            ? [0, 1, 2, 3, 4, 5, 6, 7, 8]
            : [gameState.currentZone];

        for (let zone of zones) {
          if (gameState.macro[zone]) continue;

          for (let cell = 0; cell < 9; cell++) {
            if (!gameState.board[zone][cell]) {
              moves.push({ zone, cell });
            }
          }
        }

        // If no moves in current zone, check all zones
        if (moves.length === 0) {
          for (let zone = 0; zone < 9; zone++) {
            if (gameState.macro[zone]) continue;

            for (let cell = 0; cell < 9; cell++) {
              if (!gameState.board[zone][cell]) {
                moves.push({ zone, cell });
              }
            }
          }
        }

        return moves;
      }

      function checkZoneWin(zone, player) {
        return checkWinInArray(gameState.board[zone], player);
      }

      function checkGameWin(player) {
        return checkWinInArray(gameState.macro, player);
      }

      function checkWinInArray(arr, player) {
        const winPatterns = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // Rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // Columns
          [0, 4, 8],
          [2, 4, 6], // Diagonals
        ];

        return winPatterns.some((pattern) =>
          pattern.every((index) => arr[index] === player),
        );
      }

      function isZoneFull(zone) {
        return gameState.board[zone].every((cell) => cell !== null);
      }

      function gameWin(winner) {
        gameState.gameActive = false;
        gameState.scores[winner]++;

        // Update scores display
        document.getElementById("scoreX").textContent = gameState.scores.X;
        document.getElementById("scoreO").textContent = gameState.scores.O;

        // Show win screen
        showWinScreen(winner);

        // Play victory sound
        playSound("victory");
      }

      // ===== UI UPDATES =====
      function updateStatus() {
        const status = document.getElementById("status");

        if (!gameState.gameActive) {
          status.textContent = "Game Over";
          return;
        }

        if (gameState.gameMode === "single" && gameState.aiThinking) {
          status.textContent = "AI is thinking...";
          status.className = "status-text ai-turn";
        } else if (gameState.currentPlayer === "X") {
          if (gameState.currentZone === -1) {
            status.textContent = "Player 1's turn! Click any cell";
          } else {
            status.textContent = `Player 1's turn! Play in zone ${gameState.currentZone + 1}`;
          }
          status.className = "status-text";
        } else {
          if (gameState.gameMode === "single") {
            status.textContent = "AI's turn...";
            status.className = "status-text ai-turn";
          } else {
            if (gameState.currentZone === -1) {
              status.textContent = "Player 2's turn! Click any cell";
            } else {
              status.textContent = `Player 2's turn! Play in zone ${gameState.currentZone + 1}`;
            }
            status.className = "status-text p2-turn";
          }
        }
      }

      function updatePlayerIndicators() {
        const playerX = document.getElementById("playerX");
        const playerO = document.getElementById("playerO");

        playerX.classList.toggle("active", gameState.currentPlayer === "X");
        playerO.classList.toggle("active", gameState.currentPlayer === "O");

        // Add specific class for player 2 in multiplayer
        if (gameState.currentPlayer === "O" && gameState.gameMode === "multi") {
          playerO.classList.add("p2");
        } else {
          playerO.classList.remove("p2");
        }
      }

      function updateTimer() {
        if (!gameState.startTime) return;

        const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;

        document.getElementById("gameTime").textContent =
          `${minutes}:${seconds.toString().padStart(2, "0")}`;
      }

      function showWinScreen(winner) {
        const winScreen = document.getElementById("winScreen");
        const winTitle = document.getElementById("winTitle");
        const winnerSymbol = document.getElementById("winnerSymbol");

        if (winner === "draw") {
          winTitle.textContent = "DRAW!";
          winnerSymbol.textContent = "ü§ù";
          winnerSymbol.className = "winner-symbol";
        } else {
          if (gameState.gameMode === "single") {
            winTitle.textContent = winner === "X" ? "YOU WIN!" : "AI WINS!";
          } else {
            winTitle.textContent =
              winner === "X" ? "PLAYER 1 WINS!" : "PLAYER 2 WINS!";
          }
          winnerSymbol.textContent = winner;
          winnerSymbol.className = `winner-symbol winner-${winner.toLowerCase()}`;
        }

        // Update stats
        document.getElementById("totalMoves").textContent = gameState.moveCount;
        document.getElementById("gameMode").textContent =
          gameState.gameMode === "single" ? "VS AI" : "MULTIPLAYER";

        winScreen.style.display = "flex";
      }

      function hideWinScreen() {
        document.getElementById("winScreen").style.display = "none";
      }

      // ===== CONTROL FUNCTIONS =====
      function newGame() {
        initGame();
      }

      function toggleAI() {
        if (gameState.gameMode !== "single") return;

        const levels = ["easy", "medium", "hard", "impossible"];
        const currentIndex = levels.indexOf(gameState.aiDifficulty);
        gameState.aiDifficulty = levels[(currentIndex + 1) % levels.length];

        const aiBtn = document.getElementById("aiBtn");
        aiBtn.innerHTML = `<span>ü§ñ AI: ${gameState.aiDifficulty.charAt(0).toUpperCase() + gameState.aiDifficulty.slice(1)}</span>`;

        // Update mode indicator
        document.getElementById("modeIndicator").textContent =
          `VS AI ‚Ä¢ ${gameState.aiDifficulty.charAt(0).toUpperCase() + gameState.aiDifficulty.slice(1)}`;
      }

      function toggleSound() {
        gameState.soundEnabled = !gameState.soundEnabled;
        const soundBtn = document.getElementById("soundBtn");
        soundBtn.innerHTML = `<span>üîä Sound ${gameState.soundEnabled ? "On" : "Off"}</span>`;
      }

      function showHelp() {
        alert(`üéÆ QUANTUM GRID - ULTIMATE TIC-TAC-TOE üéÆ

HOW TO PLAY:
‚Ä¢ This is Ultimate Tic-Tac-Toe - 9 small boards in 1 big board
‚Ä¢ Player 1 is X (Blue), Player 2/AI is O (Pink)
‚Ä¢ Your move determines where opponent plays next
‚Ä¢ Win 3 small boards in a row to win the game

RULES:
1. Your first move can be anywhere
2. Next move must be in the small board corresponding to the cell you just played
3. Win a small board by getting 3 in a row
4. If a small board is full, it's a tie (marked with "T")
5. Win 3 small boards in a row to win the game

GAME MODES:
‚Ä¢ VS AI: Play against computer with 4 difficulty levels
‚Ä¢ MULTIPLAYER: Play with a friend on the same device

CONTROLS:
‚Ä¢ Click any valid cell to place your symbol
‚Ä¢ Change AI difficulty anytime (in VS AI mode)
‚Ä¢ Toggle sound on/off
‚Ä¢ Return to main menu anytime

Good luck!`);
      }

      function playAgain() {
        hideWinScreen();
        initGame();
      }

      // ===== AUDIO =====
      function playSound(type) {
        if (!gameState.soundEnabled) return;

        try {
          const audioContext = new (
            window.AudioContext || window.webkitAudioContext
          )();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          let frequency = 440;
          let duration = 0.1;

          switch (type) {
            case "move":
              frequency = gameState.currentPlayer === "X" ? 440 : 330;
              duration = 0.1;
              break;
            case "win":
              frequency = 880;
              duration = 0.3;
              break;
            case "victory":
              frequency = 660;
              duration = 0.5;
              break;
          }

          oscillator.frequency.setValueAtTime(
            frequency,
            audioContext.currentTime,
          );
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + duration,
          );

          oscillator.start();
          oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
          // Audio not supported - fail silently
        }
      }

      // ===== PARTICLES BACKGROUND =====
      function initParticles() {
        const canvas = document.getElementById("particles");
        const ctx = canvas.getContext("2d");
        const particles = [];

        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }

        function createParticle() {
          return {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 0.5,
            speedX: (Math.random() - 0.5) * 0.5,
            speedY: (Math.random() - 0.5) * 0.5,
            color:
              Math.random() > 0.5
                ? "rgba(59, 130, 246, 0.3)"
                : "rgba(139, 92, 246, 0.3)",
          };
        }

        function init() {
          resizeCanvas();
          for (let i = 0; i < 50; i++) {
            particles.push(createParticle());
          }
          animate();
        }

        function animate() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          particles.forEach((p) => {
            p.x += p.speedX;
            p.y += p.speedY;

            if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
            if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;

            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          });

          requestAnimationFrame(animate);
        }

        window.addEventListener("resize", resizeCanvas);
        init();
      }

      // ===== MULTIPLAYER HANDLING =====
      // For multiplayer, O clicks are handled through the same cell click event
      // We need to modify the makeMove function to handle both players
      // Actually, we already have the logic - when currentPlayer is "O" in multiplayer,
      // the player can click to make their move

      // Modify the click handler to handle multiplayer
      document.addEventListener("click", function (e) {
        // If the click is on a cell and we're in multiplayer mode with O's turn
        if (
          e.target.classList.contains("cell") &&
          gameState.gameActive &&
          gameState.gameMode === "multi" &&
          gameState.currentPlayer === "O"
        ) {
          const id = e.target.id;
          if (!id.startsWith("cell-")) return;

          const parts = id.split("-");
          const zone = parseInt(parts[1]);
          const cell = parseInt(parts[2]);

          // Validate and make move for Player 2
          if (!isValidMove(zone, cell)) return;

          playSound("move");

          // Execute move for Player 2
          gameState.board[zone][cell] = "O";
          gameState.moveCount++;

          // Check if zone is won
          if (checkZoneWin(zone, "O")) {
            gameState.macro[zone] = "O";
            playSound("win");
          } else if (isZoneFull(zone)) {
            gameState.macro[zone] = "T";
          }

          // Check for game win
          if (checkGameWin("O")) {
            gameWin("O");
            return;
          }

          // Determine next zone
          gameState.currentZone = gameState.macro[cell] ? -1 : cell;
          gameState.currentPlayer = "X";

          // Update UI
          updateBoard();
          updateStatus();
          updatePlayerIndicators();
        }
      });

      // ===== INITIALIZE =====
      document.addEventListener("DOMContentLoaded", () => {
        // Set default mode selection
        selectMode("single");
        selectDifficulty("hard");

        // Start particles
        initParticles();
      });
    </script>
  </body>
</html>
